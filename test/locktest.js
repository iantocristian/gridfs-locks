// Generated by CoffeeScript 1.7.1
(function() {
  var Db, GridStore, Lock, LockCollection, ObjectID, Server, assert, chunkSize, db, myTimeout;

  Db = require('mongodb').Db;

  GridStore = require('mongodb').GridStore;

  Server = require('mongodb').Server;

  ObjectID = require('mongodb').ObjectID;

  assert = require('assert');

  Lock = require('./index').Lock;

  LockCollection = require('./index').LockCollection;

  chunkSize = 256 * 1024;

  myTimeout = function(t, cb) {
    return setTimeout(cb, t);
  };

  db = new Db('test', new Server('127.0.0.1', 27017), {
    w: 1
  });

  db.open(function(err, db) {
    var fileId, vc;
    fileId = "Thatfile";
    vc = db.collection('fs.files');
    return vc.insert({
      _id: fileId,
      value: 0
    }, function(err, doc) {
      var closeUp, counter, done, fail_rate, locks, max, read_failed, read_nolock, read_waiting, write_failed, write_nolock, write_waiting;
      counter = 1;
      done = 0;
      read_failed = 0;
      read_nolock = 0;
      read_waiting = 0;
      write_failed = 0;
      write_nolock = 0;
      write_waiting = 0;
      max = 10000;
      fail_rate = 0.1;
      locks = [];
      closeUp = function() {
        if (done + read_failed + write_failed + write_nolock + read_nolock === max - 1) {
          console.log("All work complete, closing!\n Done: " + done + " read fail: " + read_failed + " read no lock: " + read_nolock + " write fail: " + write_failed + " write no lock " + write_nolock);
          return db.close();
        }
      };
      return LockCollection.create(db, "fs", {
        lockExpiration: 15,
        pollingInterval: 1
      }, function(err, lockColl) {
        var spawner;
        if (err) {
          throw err;
        }
        spawner = function() {
          var c, fail;
          if (counter < max) {
            c = counter;
            locks[c] = Lock(fileId, lockColl, {
              timeOut: 30
            });
            fail = false;
            if (Math.random() <= 0.01) {
              fail = Math.random() < fail_rate;
              write_waiting++;
              locks[c].obtainWriteLock(function(err, res) {
                if (err) {
                  throw err;
                }
                write_waiting--;
                if (res && !fail) {
                  return vc.update({
                    _id: fileId
                  }, {
                    $inc: {
                      value: 0.5
                    }
                  }, function(err, doc) {
                    return myTimeout(Math.floor(Math.random() * 250), function() {
                      return vc.update({
                        _id: fileId
                      }, {
                        $inc: {
                          value: 0.5
                        }
                      }, function(err, doc) {
                        return locks[c].releaseLock(function(err, res) {
                          if (err) {
                            throw err;
                          }
                          console.log("Value updated. " + c + " " + res.reads + " " + res.writes + " " + res.read_locks + " " + res.write_request + " " + read_waiting + " " + write_waiting);
                          done++;
                          return closeUp();
                        });
                      });
                    });
                  });
                } else {
                  if (fail) {
                    console.log("#### Write lock failure " + c);
                    write_failed++;
                  } else {
                    write_nolock++;
                  }
                  return closeUp();
                }
              });
            } else {
              read_waiting++;
              locks[c].obtainReadLock(function(err, res) {
                if (err) {
                  throw err;
                }
                read_waiting--;
                if (res && !fail) {
                  return myTimeout(Math.floor(Math.random() * 250), function() {
                    return vc.findOne({
                      _id: fileId
                    }, function(err, doc) {
                      return locks[c].releaseLock(function(err, res) {
                        if (err) {
                          throw err;
                        }
                        console.log("Value : " + c + " " + res.reads + " " + res.writes + " " + doc.value + " " + res.read_locks + " " + res.write_request + " " + read_waiting + " " + write_waiting);
                        done++;
                        return closeUp();
                      });
                    });
                  });
                } else {
                  if (fail) {
                    read_failed++;
                    console.log("#### Read lock failure " + c);
                  } else {
                    read_nolock++;
                  }
                  return closeUp();
                }
              });
            }
            counter++;
            return myTimeout(Math.floor(Math.random() * 200), spawner);
          }
        };
        return spawner();
      });
    });
  });

}).call(this);
